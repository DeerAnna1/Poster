<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>学术海报（网页版）</title>
    <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS_HTML"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden; /* 隐藏页面滚动条 */
            position: relative; /* 使按钮定位相对 */
        }
        .swiper-container {
            width: 100%;
            height: 100vh;
        }
        .swiper-slide {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            position: relative; /* 相对定位以便放置按钮 */
            cursor: pointer; /* 鼠标指针为手形 */
            overflow: hidden; /* 隐藏超出部分 */
        }
        /* 自定义按钮样式 */
        .swiper-button-next,
        .swiper-button-prev {
            display: none; /* 隐藏左右按钮 */
        }
        /* 按钮样式 */
        .button-container {
            position: fixed; /* 固定定位 */
            bottom: 20px; /* 距离底部20px */
            left: 50%;
            transform: translateX(-50%); /* 居中 */
            display: flex;
            gap: 10px; /* 按钮之间的间距 */
            z-index: 10; /* 确保按钮在其他元素上方 */
        }
        .button-sort {
            position: fixed; /* 固定定位 */
            top: 10px; /* 距离顶部20px */
            left: 0;
            z-index: 10; /* 确保按钮在其他元素上方 */
        }
        .action-button {
            background-color: #007bff; /* 按钮背景色 */
            color: white; /* 按钮文字颜色 */
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s; /* 背景色过渡效果 */
        }
        .action-button:hover {
            background-color: #0056b3; /* 悬停时的背景色 */
        }
        .action-button2 {
            background-color: #c3c3bd; /* 按钮背景色 */
            border: none;
            border-radius: 5px;
            padding: 10px 10px;
            font-size: 16px;
            cursor: pointer;
            transition: background-color 0.3s; /* 背景色过渡效果 */
        }
        .action-button2:hover {
            background-color: #bfc1c2; /* 悬停时的背景色 */
        }
        .close-bottom {
            color: white; /* 按钮文字颜色 */
            position: absolute; /* 固定定位 */
            left: 50%; /* 水平居中 */
            bottom: 20px; /* 距离底部20px */
            transform: translateX(-50%); /* 居中 */
            background: rgba(0, 0, 0, 0.8); /* 黑色透明背景 */
            border-radius: 25px; /* 圆形按钮 */
            padding: 5px 10px; /* 内边距 */
            cursor: pointer; /* 鼠标指针为手形 */
            z-index: 101; /* 确保按钮在模态框上方 */
        }
        .editor {
            width: 80%;           /* 设置宽度为80% */
            margin: 0 auto;      /* 自动水平居中 */
            text-align: left;    /* 文本左对齐（可根据需要修改） */
            padding: 20px;       /* 内边距（可根据需要调整） */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* 添加阴影效果（可选） */
            border-radius: 8px;  /* 圆角边框（可选） */
            background-color: #f9f9f9; /* 背景颜色（可选） */
        }
        /* 侧边栏样式 */
        .sidebar {
            position: fixed;
            top: 0;
            left: -50%; /* 初始位置在屏幕外 */
            width: 50%; /* 宽度为50% */
            height: 100%;
            background-color: #f9f9f9;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            transition: left 0.3s ease; /* 滑动效果 */
            z-index: 1000; /* 确保在其他元素上方 */
        }
        .sidebar.open {
            left: 0; /* 打开时移到可见区域 */
        }
        /* 下拉栏样式 */
        .dropdown {
            position: relative;
            display: inline-block;
            margin: 20px 0; /* 下拉栏的上下间距 */
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }
        .dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        .dropdown-content a:hover {
            background-color: #f1f1f1;
        }
        .dropdown:hover .dropdown-content {
            display: block;
        }
    </style>
</head>
<body>
    <div class="swiper-container" id="swiperContainer">
        <div class="swiper-wrapper">
            <div class="swiper-slide" id="item0">
                <div class="editor" id="editor1" placeholder="请输入 Markdown 文本...">
                    题目：On the Cost of Model-Serving Frameworks: An Experimental Evaluation<br>作者：Pasquale De Rosa, Yérom-David Bromberg, Pascal Felber, Djob Mvondo, Valerio Schiavoni<br>日期：2024-11-15<br>链接：http://arxiv.org/pdf/2411.10337v1<br>摘要：In machine learning (ML), the inference phase is the process of applying
pre-trained models to new, unseen data with the objective of making
predictions. During the inference phase, end-users interact with ML services to
gain insights, recommendations, or actions based on the input data. For this
reason, serving strategies are nowadays crucial for deploying and managing
models in production environments effectively. These strategies ensure that
models are available, scalable, reliable, and performant for real-world
applications, such as time series forecasting, image classification, natural
language processing, and so on. In this paper, we evaluate the performances of
five widely-used model serving frameworks (TensorFlow Serving, TorchServe,
MLServer, MLflow, and BentoML) under four different scenarios (malware
detection, cryptocoin prices forecasting, image classification, and sentiment
analysis). We demonstrate that TensorFlow Serving is able to outperform all the
other frameworks in serving deep learning (DL) models. Moreover, we show that
DL-specific frameworks (TensorFlow Serving and TorchServe) display
significantly lower latencies than the three general-purpose ML frameworks
(BentoML, MLFlow, and MLServer).
                    <br>
                    <a href="poster.html?index=0">打开海报</a>
                </div>
            </div>
            <div class="swiper-slide" id="item1">
                <div class="editor" id="editor2" placeholder="请输入 Markdown 文本...">
                    题目：Generalized Conditional Functional Principal Component Analysis<br>作者：Yu Lu, Xinkai Zhou, Erjia Cui, Dustin Rogers, Ciprian M. Crainiceanu, Julia Wrobel, Andrew Leroux<br>日期：2024-11-15<br>链接：http://arxiv.org/pdf/2411.10312v1<br>摘要：We propose generalized conditional functional principal components analysis
(GC-FPCA) for the joint modeling of the fixed and random effects of
non-Gaussian functional outcomes. The method scales up to very large functional
data sets by estimating the principal components of the covariance matrix on
the linear predictor scale conditional on the fixed effects. This is achieved
by combining three modeling innovations: (1) fit local generalized linear mixed
models (GLMMs) conditional on covariates in windows along the functional
domain; (2) conduct a functional principal component analysis (FPCA) on the
person-specific functional effects obtained by assembling the estimated random
effects from the local GLMMs; and (3) fit a joint functional mixed effects
model conditional on covariates and the estimated principal components from the
previous step. GC-FPCA was motivated by modeling the minute-level
active/inactive profiles over the day (\$1{,}440$ 0/1 measurements per person)
for \$8{,}700$ study participants in the National Health and Nutrition
Examination Survey (NHANES) 2011-2014. We show that state-of-the-art approaches
cannot handle data of this size and complexity, while GC-FPCA can.
                    <br>
                    <a href="article2.html?index=1">打开海报</a>
                </div>
            </div>
            <div class="swiper-slide" id="item2">
                <div class="editor" id="editor3" placeholder="请输入 Markdown 文本...">
                    题目：Self-interacting CBO: Existence, uniqueness, and long-time convergence<br>作者：Hui Huang, Hicham Kouhkouh<br>日期：2024-11-15<br>链接：http://arxiv.org/pdf/2411.10295v1<br>摘要：A self-interacting dynamics that mimics the standard Consensus-Based
Optimization (CBO) model is introduced. This single-particle dynamics is shown
to converge to a unique invariant measure that approximates the global minimum
of a given function. As an application, its connection to CBO with Personal
Best introduced by C. Totzeck and M.-T. Wolfram (Math. Biosci. Eng., 2020) has
been established.
                    <br>
                    <a href="article3.html?index=2">打开海报</a>
                </div>
            </div>
        </div>
    </div>
    <div class="button-container">
        <button class="action-button" onclick="handleButtonClick(event, '点击主页')">主页</button>
    </div>
    <div class="button-sort">
        <button class="action-button2" onclick="toggleSidebar()">⭕</button>
    </div>
    <div class="sidebar" id="sidebar">
        <div class="dropdown">
            <button class="action-button">选择一个关键词</button>
            <div class="dropdown-content">
                <a href="#option1">关键词 1</a>
                <a href="#option2">关键词 2</a>
                <a href="#option3">关键词 3</a>
                <a href="#option4">关键词 4</a>
            </div>
        </div>
        <button class="close-bottom" onclick="toggleSidebar()">关闭</button>
    </div>
    <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open'); // 切换侧边栏的打开状态
        }
        const swiper = new Swiper('.swiper-container', {
            direction: 'vertical',
            loop: false, // 禁用循环
            on: {
                slideChange: function () {
                    const currentIndex = this.activeIndex; // 获取当前索引
                    console.log('当前索引:', currentIndex); // 输出当前索引
                }
            }
        });
        // 页面加载时输出初始索引
        console.log('初始索引:', swiper.activeIndex); // 输出初始索引
        document.getElementById('swiperContainer').addEventListener('wheel', function(event) {
            const currentIndex = swiper.activeIndex; // 获取当前索引
            const totalSlides = swiper.slides.length; // 获取总页数
            if (event.deltaY > 0) {
                // 向下滑动
                if (currentIndex < totalSlides - 1) {
                    swiper.slideNext(); // 允许向下滑动
                }
            } else {
                // 向上滑动
                if (currentIndex > 0) {
                    swiper.slidePrev(); // 允许向上滑动
                }
            }
            event.preventDefault();
        });
        function handleButtonClick(event, buttonName) {
            event.stopPropagation();
            alert(buttonName + ' 被点击');
        }
        // 页面加载时检查锚点
        document.addEventListener('DOMContentLoaded', function() {
            if (window.location.hash) {
                const element = document.querySelector(window.location.hash);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth' }); // 平滑滚动到锚点位置
                }
            }
        });
    </script>
</body>
</html>
